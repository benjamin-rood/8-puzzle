//
//  main.cpp
//  eight-puzzle
//
//  Created by Benjamin Rood on 9/04/15.
//  Copyright (c) 2015 Dave & Ben. All rights reserved.
//

#include "algorithm.h"
#include <map>
#include <set>


int main(int argc, const char * argv[])
{
	//	A* using map
	// testing
	float actualRunningTime = 0.0f;
	clock_t startTime;
	startTime = clock();
	
	bool success = false;
	size_t highest_Q_length = 0;
	uint32_t num_of_expansions = 0;
	std::bitset<domain_size> strict_expanded_list;						//	where positions in SEL are the hash value of a Board object.
																		//	a bitset is initialised by default with all bits set to 0 (false).
	std::shared_ptr<Board> S = std::make_shared<Board>(      start5State );	//	Initialisation state (search start point). Will be immediately added to Q
	std::shared_ptr<Board> B = nullptr;
	std::stack<std::shared_ptr<Board>> expandedStack;					//	temporary stack of new Board objects generated by expanding a Board object ( by calling spawnBoardMovesFrom(Board) )
	
	
	std::multimap<fCost_t, std::shared_ptr<Board>> q_EnqueuedTree;
	std::multimap<fCost_t, std::shared_ptr<Board>>::iterator q_EnqueuedTree_It;
	std::map<hash_t, std::shared_ptr<Board>> q_hashMap;				//	using a map so we can arrange by hash for faster comparisons!
	std::map<hash_t, std::shared_ptr<Board>>::iterator q_hashMap_It;
	
//	generateManhattanHeuristic(*S);
	generateMisplacedTilesHeuristic(*S);
	q_EnqueuedTree.insert ( std::make_pair(S->getFCost(), S) );	//	first element in Q...
	q_hashMap.insert ( std::make_pair(S->getHash(), S) );			//	...and add accompanying Board state to hash map
	
	while ( q_EnqueuedTree.empty() == false )
	{
		highest_Q_length = std::max( highest_Q_length, q_EnqueuedTree.size() );	//	keeping track of Q size
		
		B = q_EnqueuedTree.begin()->second;
		q_EnqueuedTree.erase( q_EnqueuedTree.begin() );	//	once it's off the queue, surely get it actually OFF the queue?
		if ( (q_hashMap_It = q_hashMap.find( B->getHash() )) != q_hashMap.end() ) {
			q_hashMap.erase( q_hashMap_It );	//	...the same with the accompanying reference in the hash map, no?
		}
		
		
		if ( testForGoalState( *B ) )	{
			success = true;
			actualRunningTime = ((float)(clock() - startTime) / CLOCKS_PER_SEC);
			print_SUCCESS(*B, highest_Q_length, num_of_expansions, actualRunningTime);
			break;
		}
		
		expandedStack = spawnBoardMovesFrom( *B );
		strict_expanded_list.set(B->getHash());
		++num_of_expansions;
		
		while (expandedStack.empty() == false) {
			auto& top = expandedStack.top();
//			generateManhattanHeuristic(*top);
			generateMisplacedTilesHeuristic(*top);
			if ( strict_expanded_list[top->getHash()] == false ) {
				if ( (q_hashMap_It = q_hashMap.find( top->getHash() )) == q_hashMap.end() )	{	//	Not already in queue, just directly insert it
					q_EnqueuedTree.insert ( std::make_pair(top->getFCost(), top) );			//	add element in Q...
					q_hashMap.insert ( std::make_pair(top->getHash(), top) );					//	...and add accompanying Board state to hash map
				} else {
					if ( top->getFCost() < q_hashMap_It->second->getFCost() ) {
						q_EnqueuedTree_It = q_EnqueuedTree.find( q_hashMap_It->second->getFCost() );
						while ( q_EnqueuedTree_It->second->getHash() != top->getHash() ) {
							++q_EnqueuedTree_It;
							if ( q_EnqueuedTree_It == q_EnqueuedTree.end() ) break;
						}
						if ( q_EnqueuedTree_It == q_EnqueuedTree.end() )
							q_EnqueuedTree.erase( q_EnqueuedTree_It );
						q_EnqueuedTree.insert ( std::make_pair(top->getFCost(), top) );			//	add element in Q...
						q_hashMap.insert ( std::make_pair(top->getHash(), top) );					//	...and add accompanying Board state to hash map
					}

				}
			}
			
			expandedStack.pop();
		}
		
	}
	if (!( success )) print_FAIL();

	
	
	
	// BREADTH-FIRST SEARCH:
	{
		float actualRunningTime = 0.0f;
		clock_t startTime;
		startTime = clock();
		
		std::cout << "BREADTH-FIRST SEARCH\n\n";
		
		size_t highest_Q_length = 0;
		uint32_t num_of_expansions = 0;
		
		std::queue<std::shared_ptr<Board>> BreadthFirst_Q;	//	FIFO Enqueued List!
		std::stack<std::shared_ptr<Board>> tempStack;
		std::stack<std::shared_ptr<Board>> expandedStack;
		std::bitset<domain_size> visitedList;			//	the same type gets used for both visited and strict expanded list.
		//	a bitset is initialised by default with all bits set to 0 (false).

		std::shared_ptr<Board> start = std::make_shared<Board>(      start5State );
		BreadthFirst_Q.push( start );
		std::shared_ptr<Board>& B = start;


		while (!( BreadthFirst_Q.empty() ))	{
			if (highest_Q_length < BreadthFirst_Q.size() )	highest_Q_length = BreadthFirst_Q.size();
			B = BreadthFirst_Q.front();
			BreadthFirst_Q.pop();
			if ( testForGoalState(B) ) {
				actualRunningTime = ((float)(clock() - startTime) / CLOCKS_PER_SEC);
				print_SUCCESS(*B, highest_Q_length, num_of_expansions, actualRunningTime);
				break;
			}

			visitedList.set( B->getHash() );
			tempStack = spawnBoardMovesFrom( B );
			++num_of_expansions;
			
			
			while (!( tempStack.empty() ))	{
				expandedStack.push( tempStack.top() );
				tempStack.pop();
			}

			while (!( expandedStack.empty() )) {
				auto& top = expandedStack.top();
				if ( visitedList[top->getHash()] == false )
					BreadthFirst_Q.push( top );
				expandedStack.pop();
			}
		}
	}
	
}

