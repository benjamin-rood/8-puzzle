//
//  main.cpp
//  eight-puzzle
//
//  Created by Benjamin Rood on 9/04/15.
//  Copyright (c) 2015 Dave & Ben. All rights reserved.
//

#include "algorithm.h"



int main(int argc, const char * argv[])
{
	//	UCS
	{
		float actualRunningTime = 0.0f;
		clock_t startTime;
		startTime = clock();
		
		bool success = false;
		size_t highest_Q_length = 0;
		uint32_t num_of_expansions = 0;
		std::bitset<domain_size> strict_expanded_list;						//	where positions in SEL are the hash value of a Board object.
																			//	a bitset is initialised by default with all bits set to 0 (false).
																			//std::shared_ptr<Board> B = nullptr;
		std::shared_ptr<Board> S = std::make_shared<Board>( start2State );	//	Initialisation state (search start point). Will be immediately added to Q
		std::shared_ptr<Board> B = nullptr;
		std::stack<std::shared_ptr<Board>> expandedStack;					//	temporary stack of new Board objects generated by expanding a Board object ( by calling spawnBoardMovesFrom(Board) )
																			//std::shared_ptr<Board> B = nullptr;									//	working pointer
		std::vector<Board> min_heap_Q;										//	vector used as a Min Heap
		
		min_heap_Q.push_back( *S );											//	first element in Q - technically with only one element it is still a 'good' heap.
		
		while ( min_heap_Q.empty() == false )
		{
			if ( highest_Q_length < min_heap_Q.size() )						//	keeping track of Q size
				highest_Q_length = min_heap_Q.size();
			
			B = std::make_shared<Board>(min_heap_Q.front());
			if ( testForGoalState( B ) )	{
				success = true;
				actualRunningTime = ((float)(clock() - startTime) / CLOCKS_PER_SEC);
				print_SUCCESS(*B, highest_Q_length, num_of_expansions, actualRunningTime);
				break;
			}
			expandedStack = spawnBoardMovesFrom(B);
			std::pop_heap( min_heap_Q.begin(),min_heap_Q.end(), std::greater<Board>() );
			min_heap_Q.pop_back();
			strict_expanded_list.set(B->getHash());
			++num_of_expansions;
			
			while (expandedStack.empty() == false) {
				auto& top = expandedStack.top();
				
				if ( strict_expanded_list[top->getHash()] == false ) {
					min_heap_Q.push_back(*top);
					std::push_heap(min_heap_Q.begin(),min_heap_Q.end(), std::greater_equal<Board>() );
				}
				
				expandedStack.pop();
			}
		}
		if (!( success )) print_FAIL();
	}
	
	
	


	
	// BREADTH-FIRST SEARCH:
	{
		float actualRunningTime = 0.0f;
		clock_t startTime;
		startTime = clock();
		
		std::cout << "BREADTH-FIRST SEARCH\n\n";
		
		size_t highest_Q_length = 0;
		uint32_t num_of_expansions = 0;
		
		std::queue<std::shared_ptr<Board>> BreadthFirst_Q;	//	FIFO Enqueued List!
		std::stack<std::shared_ptr<Board>> tempStack;
		std::stack<std::shared_ptr<Board>> expandedStack;
		std::bitset<domain_size> visitedList;			//	the same type gets used for both visited and strict expanded list.
		//	a bitset is initialised by default with all bits set to 0 (false).

		std::shared_ptr<Board> start = std::make_shared<Board>( start2State );
		BreadthFirst_Q.push( start );
		std::shared_ptr<Board>& B = start;


		while (!( BreadthFirst_Q.empty() ))	{
			if (highest_Q_length < BreadthFirst_Q.size() )	highest_Q_length = BreadthFirst_Q.size();
			B = BreadthFirst_Q.front();
			BreadthFirst_Q.pop();
			if ( testForGoalState(B) ) {
				actualRunningTime = ((float)(clock() - startTime) / CLOCKS_PER_SEC);
				print_SUCCESS(*B, highest_Q_length, num_of_expansions, actualRunningTime);
				break;
			}

			visitedList.set( B->getHash() );
			tempStack = spawnBoardMovesFrom( B );
			++num_of_expansions;
			
			
			while (!( tempStack.empty() ))	{
				expandedStack.push( tempStack.top() );
				tempStack.pop();
			}

			while (!( expandedStack.empty() )) {
				auto& top = expandedStack.top();
				if ( visitedList[top->getHash()] == false )
					BreadthFirst_Q.push( top );
				expandedStack.pop();
			}
		}
	}
}

